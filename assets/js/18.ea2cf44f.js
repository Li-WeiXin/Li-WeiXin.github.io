(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{418:function(t,s,o){"use strict";o.r(s);var n=o(1),p=Object(n.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"_1-什么是monorepo"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-什么是monorepo"}},[t._v("#")]),t._v(" 1. 什么是Monorepo")]),t._v(" "),s("p",[t._v("Monorepo是一种项目代码管理方式，指单个仓库中管理多个项目，有助于简化代码共享、版本控制、构建和部署等方面的复杂性，并提供更好的复用性与协作性。")]),t._v(" "),s("p",[t._v("Monorepo提倡开放、透明、共享的组织文化，这种方法已经被很多大型互联网公司广泛使用，如"),s("code",[t._v("Google")]),t._v("、"),s("code",[t._v("Facebook")]),t._v("和"),s("code",[t._v("Microsoft")]),t._v("等。")]),t._v(" "),s("p",[s("code",[t._v("mono")]),t._v("来源于希腊语 μόνος ，意味单个的；"),s("code",[t._v("repo")]),t._v("是 repository 的缩写，将不同的项⽬的代码放在同⼀个代码仓库中，这种把鸡蛋放在同⼀个篮子的做法乍看之下有些奇怪。但实际上，这种管理模式有如下好处：")]),t._v(" "),s("p",[s("strong",[t._v("单一的仓库：")]),t._v("将多个项目（子包）集中在同一个项目中进行管理，减少版本冲突。")]),t._v(" "),s("p",[s("strong",[t._v("统一管理依赖：")]),t._v("通过工具（如PNPM、Lerna、Turborepo等）实现依赖统一安装和版本管理。")]),t._v(" "),s("p",[s("strong",[t._v("共享代码：")]),t._v("通过空间或内部包机制共享公共模块。")]),t._v(" "),s("p",[s("strong",[t._v("统一构建和发布：")]),t._v("可以对多个子包进行一次性构建和发布。")]),t._v(" "),s("blockquote",[s("p",[t._v("前端开发中使用的Vue、React、QianKun都是在Monorepo策略仓库中开发出来的。")])]),t._v(" "),s("p",[t._v("一个真正的Monorepo不仅仅是将多个项目的代码放在同一个代码库中。它还需要这些项目之间有明确定义的关系。如果这些项目之间没有良好定义的关系，那么就不能称之为Monorepo，项目之间应该具有良好的结构和模块化。")]),t._v(" "),s("h1",{attrs:{id:"_2-repository项目管理发展历程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-repository项目管理发展历程"}},[t._v("#")]),t._v(" 2. Repository项目管理发展历程")]),t._v(" "),s("p",[t._v("从单仓库巨石应用（Monolith），到多仓库多模块应用（Multirepo），最后转向单仓库多模块应用（Monorepo），每个阶段都有其优势和挑战。选择哪种方式取决于项目的具体需求和团队的工作流程。")]),t._v(" "),s("h2",{attrs:{id:"_2-1-单仓库巨石应用-monolith"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-单仓库巨石应用-monolith"}},[t._v("#")]),t._v(" 2.1 单仓库巨石应用（Monolith）")]),t._v(" "),s("p",[t._v("这种结构在项目初期比较常见，由于一切都在一个仓库里，所以便于管理和部署。但随着项目的迭代，这种结构的缺点逐渐显现，包括但不限于构建时间的增长，代码冲突的频繁、以及难以维护。")]),t._v(" "),s("h2",{attrs:{id:"_2-2-多仓库多应用-multirepo"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-多仓库多应用-multirepo"}},[t._v("#")]),t._v(" 2.2 多仓库多应用（Multirepo）")]),t._v(" "),s("p",[t._v("为了克服巨⽯应⽤的缺点，项⽬可能被拆分成多个较⼩的模块，每个模块使⽤单独的仓库管理。这样做可以提⾼模块的独⽴性，便于团队并⾏开发 和维护，但也带来了新的挑战，比如跨仓库的依赖管理、版本同步问题以及工作流程的复杂性的增加。")]),t._v(" "),s("h2",{attrs:{id:"_2-3-单仓库多应用-monorepo"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-单仓库多应用-monorepo"}},[t._v("#")]),t._v(" 2.3 单仓库多应用（Monorepo ）")]),t._v(" "),s("p",[t._v("为了解决多仓库管理带来的问题，有些团队和项⽬转向使⽤单仓库来管理多个模块。这种⽅式可以简化跨模块的依赖管理，提⾼代码共享的效率，并且可以统⼀构建和测试流程。不过，Monorepo也有其挑战，比如需要更精细的权限控制、针对大规模仓库的性能优化等。")]),t._v(" "),s("p",[s("strong",[t._v("总结：")]),t._v("每种⽅法都有其适⽤场景，没有绝对的好坏。例如，⼩到中型项⽬可能会更倾向于使⽤ Monolith 或MultiRepo，⽽⼤型项⽬和⼤型团队可能会从 MonoRepo中获益，尤其是当需要 频繁地跨模块协作时。在选择最适合⾃⼰项⽬的策略时，需要权衡各种因素，包括团队规模、 项⽬复杂度、构建和测试流程的需求等。")]),t._v(" "),s("p",[t._v("Repository项目管理演进")]),t._v(" "),s("p",[t._v("⼀个真正的 Monorepo 不仅仅是将多个项⽬的代码放在同⼀个代码库中。它还需要这些项⽬之间有明确定义的关系。如果这些项⽬之间没有良好定义的关系，那么就不能称之为Monorepo。")]),t._v(" "),s("p",[t._v("类似地，如果⼀个代码库中包含了⼀个庞⼤的应⽤，⽽没有对其进⾏分割和封装，那么这只是⼀个⼤型的代码库，而不是真正的Monorepo。")]),t._v(" "),s("p",[t._v("Monorepo 中的各个项⽬（或模块、组件）之间应该有清晰、明确的依赖关系。这有助于确保模块间可以高效协作，同时保持一定程度的独立性和可重用性。")]),t._v(" "),s("h1",{attrs:{id:"_3-monorepo-优劣"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-monorepo-优劣"}},[t._v("#")]),t._v(" 3. Monorepo 优劣")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("场景")]),t._v(" "),s("th",[t._v("Multirepo")]),t._v(" "),s("th",[t._v("Monorepo")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("代码可⻅性")]),t._v(" "),s("td",[t._v("✅由于项⽬被分散在不同的仓库中，可以对每个仓库实施独⽴的访问控制，这有助于保护敏感代码，减少安全风险。❌由于代码分散在多个仓库中，重⽤通⽤代码或库变得更加困难。开发⼈员可能需要复制代码到他们的仓库中，这会导致重复工作和加重维护难度。")]),t._v(" "),s("td",[t._v("✅所有代码都在⼀个仓库中，使 得代码的共享和重⽤变得⾮常⽅便。开发⼈员可以轻松访问和使⽤公共库和⼯具。❌虽然可以通过精细的权限控制限制对特定代码部分的访问，但在⼤型MonoRepo中管理这些权限会变得复杂&耗时。")])]),t._v(" "),s("tr",[s("td",[t._v("依赖管理")]),t._v(" "),s("td",[t._v("✅ 每个项⽬可以独⽴管理⾃⼰的依赖版本，这有助于避免因共享依赖导致的版本冲突问题。 ❌ 多个项⽬可能会依赖同⼀库的不同版本，这可能导致重复的配置⼯作和维护成本。❌当共享的库需要更新时，各个 项⽬需要分别进⾏更新，这可能导致同步和⼀致性问题。❌如果项⽬间存在依赖，管理依赖项会变得复杂。")]),t._v(" "),s("td",[t._v("✅ 所有项⽬共享相同的依赖库版 本，这简化了依赖管理，减少了版本冲突的可能性。✅ 当共享库需要更新时，整个仓库中的所有项⽬可以同时更新，确保了依赖的⼀致性。✅ 由于所有项⽬使⽤相同的依赖版本，当发现某个依赖的问题时，可以快速地识别出所有受影响的项⽬并进⾏修复。❌所有项⽬必须使⽤相同版本的依赖，这可能限制了某些项⽬使⽤特定版本的能⼒，特别是当某些项⽬需要使用较新或较久版本时候。")])]),t._v(" "),s("tr",[s("td",[t._v("开发迭代")]),t._v(" "),s("td",[t._v("✅ 在多仓库模式下，每个仓库可以独⽴进⾏迭代，不受其他项⽬进度的影响。这意味着团队可以根据每个项⽬的需求和优先级安排迭代计划。✅ 由于每个项⽬独⽴管理，团队可以为每个项⽬选择最适合的技术栈、⼯具和流程，提⾼了迭代过程的灵活性。❌当需要在多个项⽬之间进⾏协 作或共享代码时，跨仓库的协作可能会增加沟通和整合的成本。❌在多仓库模式下，跨项⽬的依 赖管理可能会变得复杂，需要额外的努⼒来确保依赖项的⼀致性和兼容性，加大工作量。")]),t._v(" "),s("td",[t._v("✅ 所有项⽬和模块共享同⼀个仓库，使得团队可以采⽤统⼀的⼯作流程、构建和测试⼯具，简化了迭代过程。✅ 当共享库需要更新时，整个仓 库中的所有项⽬可以同时更新，确保了依赖的⼀致性。❌ 在 MonoRepo 中，所有项⽬共享同⼀个版本历史，这可能会导致版本控制⽇志变得杂乱⽆ 章，使得追踪特定项⽬的更改变得更加困难。❌对于⾮常⼤的仓库，构建和测试的速度可能会成为问题，尤其是当不需要构建整个仓库的所有部分时。虽然有策略如增量构建和缓存可以缓解这个问题，但需要额外的配置和维护⼯作。")])]),t._v(" "),s("tr",[s("td",[t._v("⼯程配置")]),t._v(" "),s("td",[t._v("✅ 每个仓库可以有其独⽴的构建、测试和部署配置，这允许项 ⽬根据⾃⼰的特定需求定制化⼯ 程配置，提供了⾼度的灵活性。 ✅ 相对于 MonoRepo，单个项⽬的配置通常更简单、更直接， 因为它只需要关注⾃⾝的需求，⽽不是必须考虑到与其他项⽬的协作和兼容性。❌随着仓库数量的增加，重复的配置和⼯具链设置可能导致维护成本增加。每个项⽬可能需要单独维护构建脚本、依赖管理⽂件、CI/CD 配置等。❌在多仓库环境中，不同项⽬之间的配置可能会出现不⼀致，导致构建、测试和部署流程的差 异，增加了团队成员之间协作的 复杂性。")]),t._v(" "),s("td",[t._v("✅ 所有项⽬共享同⼀个构建系统 和⼯具链，这有助于确保整个代码库的⼀致性和可维护性，简化了⼯程配置的管理。✅ 具和依赖库的版本可以在整个 仓库中统⼀管理，减少了版本冲突的可能性，并确保所有项⽬都使⽤了正确的⼯具和库版本。❌ 由于所有项⽬使⽤相同的依赖版本，当发现某个依赖的问题时，可以快速地识别出所有受影响的项⽬并进⾏修复。随着项⽬数量和类型的增加，MonoRepo的配置可能变得复杂，需要更复杂的⼯具和脚本来⽀持不同类型的项⽬和构建流程。❌ 对于⼤型 MonoRepo，构建和测试整个仓库可能⾮常耗时，尽管可以通过一些优化技术（如增量构建和缓存）来缓解这⼀问题。")])]),t._v(" "),s("tr",[s("td",[t._v("构建部署")]),t._v(" "),s("td",[t._v("✅ 每个仓库可以独⽴构建和部署，这允许项⽬团队按照⾃⼰的时间表和需求来更新服务，提⾼了部署的灵活性。✅ 项⽬之间的隔离性减少了构建和部署过程中的相互影响，⼀个项⽬的更改不会直接影响到其他项⽬的构建或稳定性。❌在多仓库结构中，相似的构建和部署流程可能需要在多个项⽬中重复配置，导致维护成本和⼯作量增加。❌当项⽬之间存在依赖关系时， 协调和同步不同仓库的构建和部署变得更加复杂，尤其是在进⾏ ⼤规模更新时。")]),t._v(" "),s("td",[t._v("✅ 所有项⽬共享同⼀个构建系统，这有助于简化和标准化构建流程，提⾼效率。✅ 在 MonoRepo 中，涉及多个项⽬的更改可以在⼀个提交中完 成，这简化了回滚和跟踪更改的过程，提⾼了部署的可靠性。✅ 由于所有代码都在同⼀个仓库 中，管理和升级跨项⽬依赖变得更加容易，有助于确保依赖的⼀致性。❌ MonoRepo 可能限制了部署粒度，因为所有项⽬共享相同的构建和部署流程。这可能导致即使只需部署⼀个⼩改动，也可能需要重新构建和部署整个代码库 中的多个项⽬。")])])])]),t._v(" "),s("h1",{attrs:{id:"_4-monorepo的使用场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-monorepo的使用场景"}},[t._v("#")]),t._v(" 4. Monorepo的使用场景")]),t._v(" "),s("p",[t._v("Monorepo（单仓库）模式适⽤于多种场景，特别是在以下情况下，使⽤ Monorepo 可以带来显著的好处：")]),t._v(" "),s("ol",[s("li",[s("p",[s("strong",[t._v("团队协作：")]),t._v(" 当⼤型团队在多个相关项⽬上协作时，Monorepo 可以简化协作流程。由于所有项⽬都位于同⼀仓库中，团队成员可以轻松访问和修改跨项⽬的代码，促进了团队间的沟通和合作。")])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("微服务架构：")]),t._v(" 在微服务架构中，系统由多个⼩型、独⽴服务组成。使⽤ Monorepo 可以⽅便地管理这些服务的代码，通过将多个前端项目整合为一个Monorepo，来确保服务之间的兼容性，并简化跨服务的重构和共享代码。")])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("多平台 / 多产品/模块开发：")]),t._v("对于跨多个平台（如 Web、iOS、Android）或多个产品线开发的公司，Monorepo 可以提供⼀个统⼀的代码基础，使得共享通⽤库、组件和⼯具变得简单，同时保持构建和发布流程的⼀致性。")])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("共享库和组件：")]),t._v("在开发涉及多个共享库或可重⽤组件的项⽬时，Monorepo 允许开发⼈员轻松更新和维护这些共享资源。这有助于提⾼代码重⽤率，降低维护成本。")])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("统⼀的⼯具和流程：")]),t._v(" 对于希望统⼀代码⻛格、构建⼯具、测试框架和部署流程的团队，Monorepo 提供了⼀个共同的基础设施，有助于标准化开发实践，简化新成员的⼊职过程。")])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("原⼦性更改和重构：")]),t._v(" 当需要对跨多个项⽬或模块的代码进⾏重构或更新时，Monorepo 使得这些更改可以作为⼀个原⼦提交进⾏，降低了部署和回滚的复杂性。")])])]),t._v(" "),s("h1",{attrs:{id:"_5-pnpm与monorepo的最佳实践"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-pnpm与monorepo的最佳实践"}},[t._v("#")]),t._v(" 5. pnpm与Monorepo的最佳实践")]),t._v(" "),s("h2",{attrs:{id:"_5-1-pnpm简介"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-pnpm简介"}},[t._v("#")]),t._v(" 5.1 pnpm简介")]),t._v(" "),s("blockquote",[s("p",[t._v("中文官网：https://www.pnpm.cn/installation")])]),t._v(" "),s("p",[s("strong",[t._v("pnpm优势：")])]),t._v(" "),s("ul",[s("li",[s("p",[t._v("链接机制")])]),t._v(" "),s("li",[s("p",[t._v("缓存机制，寻址")])]),t._v(" "),s("li",[s("p",[t._v("原生支持workspace")])]),t._v(" "),s("li",[s("p",[t._v("磁盘占用少")])])]),t._v(" "),s("p",[t._v("核⼼亮点：软链接和硬链接，pnpm 使⽤⼀种称为内容寻址存储的⽅法（中心化思想）来保存依赖项。在这种机制下，依赖项的存储位置基于其内容的哈希值，这意味着：")]),t._v(" "),s("p",[t._v("其中⼀个受⼤家⽐较欢迎的就是我们打开 pnpm 官⽹就能直接看到的内容，那就是安装快：")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://nio.feishu.cn/space/api/box/stream/download/asynccode/?code=YmYzYmI3YjgwZDM5MmEzMTM3MDM4ZDlmMTU4NTJiZTBfYTBiWlJub3hCbEhJOU01djIydlhOZzlDZG5KRU5mSWNfVG9rZW46UDdpdWJvdWhob3VjeGt4eGVncmM3Ylg1bmxnXzE3NDExNDAzOTI6MTc0MTE0Mzk5Ml9WNA",alt:""}})]),t._v(" "),s("p",[t._v("pnpm 在安装依赖包时，主要经历了以下三个步骤：解析依赖、获取依赖以及链接依赖。这个 过程通过优化来确保⾼效的依赖管理，尤其在处理⼤型项⽬或 Monorepo 时。")]),t._v(" "),s("ol",[s("li",[s("p",[t._v(" 解析依赖（Dependency Resolution） 在这个阶段，pnpm 需要确定要安装的每个依赖包的具体版本。它会查看项⽬的 package.json ⽂件以及任何现有的锁⽂件（如 pnpm-lock.yaml），来决定哪些版本的包需要被安装。解析依赖时，pnpm 会遵循以下规则：")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("版本兼容性：基于 package.json 中指定的版本范围，选择与之兼容的最新版本。")])]),t._v(" "),s("li",[s("p",[t._v(" 锁⽂件：如果存在锁⽂件，pnpm 会优先使⽤锁⽂件中锁定的版本，以确保依赖的⼀致性和项⽬的可重现性。")])])])]),t._v(" "),s("li",[s("p",[t._v("获取依赖（Fetching Dependencies） ⼀旦确定了需要安装的依赖版本，pnpm将开始获取这些依赖包。这个过程包括以下⼏个步骤：")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("检查全局存储：pnpm ⾸先会检查其全局存储中是否已经存在所需版本的依赖包。如果已经存在，就不需要从远程仓库下载，直接重⽤即可。")])]),t._v(" "),s("li",[s("p",[t._v("下载缺失的依赖：对于全局存储中不存在的依赖，pnpm 会从 npm 或其他配置的仓库下载它们。下载的依赖包会被存储在全局存储中，以便复用。")])]),t._v(" "),s("li",[s("p",[t._v(" 内容寻址存储：pnpm 使⽤内容寻址⽅式来存储依赖包，即根据包内容的哈希值来确定存储路径。这确保了相同内容的包在全局存储中只有⼀份副本，节省了磁盘空间。")])])])]),t._v(" "),s("li",[s("p",[t._v("链接依赖（Linking Dependencies） 获取依赖包之后，pnpm 需要将这些依赖链接到项⽬的 node_modules ⽬录中，使得项⽬能够使⽤这些依赖。这个步骤涉及：")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("创建硬链接和符号链接：对于每个依赖包，pnpm 会在项⽬的 node_modules ⽬录中创建指向全局存储中相应包的硬链接。如果是包内部的依赖，还可能创建符号链接来保持正确的依赖结构。")])]),t._v(" "),s("li",[s("p",[t._v("pnpm 通过构建⼀个虚拟的 node_modules ⽬录来模拟传统的嵌套依赖结构，但实际上依赖之间是通过符号链接相连的。这样做既保持了 npm ⽣态的兼容性，⼜避免了重复的依赖副本和深层嵌套的问题。")])]),t._v(" "),s("li",[s("p",[t._v("通过这种链接⽅式，pnpm 确保了项⽬只能访问其直接依赖的包，防⽌了对未声明依赖的意外访问，提⾼了项⽬的稳定性和安全性。")])])])])]),t._v(" "),s("p",[t._v("通过上述三个步骤，pnpm 实现了对依赖的⾼效管理，优化了存储空间的使⽤，加快了依赖安装的速度，同时还保证了项⽬依赖的⼀致性和隔离性。")]),t._v(" "),s("h2",{attrs:{id:"_5-2-统一配置-合并同类项"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-统一配置-合并同类项"}},[t._v("#")]),t._v(" 5.2 统一配置：合并同类项 ")]),t._v(" "),s("p",[t._v("在 Monorepo 项⽬中统⼀配置 ESLint、TypeScript 可以帮助保持代码的⼀致性，简化项目维护，并提高开发效率。")]),t._v(" "),s("h3",{attrs:{id:"typescript"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#typescript"}},[t._v("#")]),t._v(" Typescript")]),t._v(" "),s("p",[t._v("我们可以在 packages ⽬录中放置 tsconfig.settting.json ⽂件，并在⽂件中定义通⽤的 ts 配置，然后，在每个⼦项⽬中，我们可以通过 extends 属性，引⼊通⽤配置，并设置 compilerOptions.composite的值为true，理想情况下，子项目的tsconfig文件应该包含如下内容：")]),t._v(" "),s("div",{staticClass:"language-json line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-json"}},[s("code",[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 继承 packages ⽬录下通⽤配置")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token property"}},[t._v('"extends"')]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"../../tsconfig.setting.json"')]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//⽤于帮助 TypeScript 快速确定引⽤⼯程的输出⽂件位置")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token property"}},[t._v('"compilerOptions"')]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token property"}},[t._v('"composite"')]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token property"}},[t._v('"outDir"')]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"dist"')]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token property"}},[t._v('"rootDir"')]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"src"')]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token property"}},[t._v('"include"')]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"src"')]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br")])]),s("h3",{attrs:{id:"eslint"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#eslint"}},[t._v("#")]),t._v(" Eslint")]),t._v(" "),s("p",[t._v("对于 eslint，我们可以使⽤相同的思想来实现这⼀规则，在包的.eslint.js文件中，使用extends字段来继承顶层配置，并添加或覆盖规则。")]),t._v(" "),s("div",{staticClass:"language-javascript line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[t._v("module"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("exports "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" \n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("extends")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"../../.eslintrc.js"')]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token literal-property property"}},[t._v("rules")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" \n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//重写或添加规则")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br")])]),s("h1",{attrs:{id:"_6-传统架构到monorepo的演进"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-传统架构到monorepo的演进"}},[t._v("#")]),t._v(" 6. 传统架构到Monorepo的演进")]),t._v(" "),s("ul",[s("li",[s("p",[s("strong",[t._v("阶段1: ")]),t._v("传统架构基础痛点（主要矛盾）")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("代码先集中化，将多个关联项目统一到一个gitlab")])]),t._v(" "),s("li",[s("p",[t._v("工具引入，pnpm workspace")])]),t._v(" "),s("li",[s("p",[t._v("CI/CD 重构")])])])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("阶段2: ")]),t._v("具体Monorepo架构")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("公共模块抽离")])]),t._v(" "),s("li",[s("p",[t._v("pnpm、turbo 解决子包与主包关系")])])])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("阶段3: ")]),t._v("自动化构建流程优化")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("打包方案："),s("strong",[t._v("vite")]),t._v("、webpack、rollup、parcel、"),s("strong",[t._v("tsup")]),t._v("、esbuild、swc、rolldown ")])]),t._v(" "),s("li",[s("p",[t._v("构建流程优化，依赖关系（循环依赖引用）、哪些包需要前置依赖/后置依赖")])]),t._v(" "),s("li",[s("p",[t._v("发布，npm publish、docker 镜像")])]),t._v(" "),s("li",[s("p",[t._v("监控和测试")])])])]),t._v(" "),s("li",[s("p",[t._v("关键性的MileStone")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("项目统一")])]),t._v(" "),s("li",[s("p",[t._v("pnpm配置")])]),t._v(" "),s("li",[s("p",[t._v("依赖管理")])]),t._v(" "),s("li",[s("p",[t._v("统一化脚本")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("工程化脚本：package.json中的script")])]),t._v(" "),s("li",[s("p",[t._v("部署阶段脚本：scripts 文件夹")])])])])])])]),t._v(" "),s("h1",{attrs:{id:"_7-参考文献"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7-参考文献"}},[t._v("#")]),t._v(" 7. 参考文献")]),t._v(" "),s("p",[s("a",{attrs:{href:"https://turbo.rust-lang.net.cn/repo/docs",target:"_blank",rel:"noopener noreferrer"}},[t._v("Turborepo 文档"),s("OutboundLink")],1)]),t._v(" "),s("p",[s("a",{attrs:{href:"https://www.pnpm.cn/motivation",target:"_blank",rel:"noopener noreferrer"}},[t._v("pnpm中文官网"),s("OutboundLink")],1)])])}),[],!1,null,null,null);s.default=p.exports}}]);